# -*- coding: utf-8 -*-

"""
/***************************************************************************
 LinhasGeoIME
                                 A QGIS plugin
 Plugin referente ao projeto de fim de curso de 2025
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-07-10
        copyright            : (C) 2025 by Ana Paula Pires dos Santos, Paulo Melo Coutinho Neves, Gabriella Bezerra Vale
        email                : anapaulapiressantos19@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Ana Paula Pires dos Santos, Paulo Melo Coutinho Neves, Gabriella Bezerra Vale'
__date__ = '2025-07-10'
__copyright__ = '(C) 2025 by Ana Paula Pires dos Santos, Paulo Melo Coutinho Neves, Gabriella Bezerra Vale'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.core import (
    QgsProcessingAlgorithm,
    QgsProcessingParameterEnum,
    QgsProcessingParameterFile,
    QgsProcessingParameterFeatureSink,
    QgsFeature,
    QgsFields,
    QgsWkbTypes,
    QgsCoordinateReferenceSystem,
    QgsGeometry,
    QgsPointXY
)
from qgis.PyQt.QtCore import QCoreApplication
from geographiclib.geodesic import Geodesic
from geopy.distance import geodesic as vincenty 
from pyproj import Geod
import csv
import pandas as pd

class LinhasGeoIMEAlgorithm(QgsProcessingAlgorithm):
    """
    Algoritmo que permite o usuário importar um .xls, escolher o método e
    algoritmo geodésico, e processar os dados conforme a escolha.
    """

    def tr(self, text):
        return QCoreApplication.translate('Processing', text)
         def _read_float(self, row, keys, row_idx, feedback):
        for k in keys:
            if k in row and str(row[k]).strip() != '':
                val_str = str(row[k]).strip().replace(',', '.')
                try:
                    return float(val_str)
                except ValueError:
                    feedback.reportError(f"Linha {row_idx}: valor não numérico em '{k}' -> '{row[k]}'")
                    raise
        feedback.reportError(f"Linha {row_idx}: nenhuma das chaves {keys} presente/preenchida.")
        raise ValueError("Campo obrigatório ausente")

    def _check_ranges(self, lat, lon, azi=None, dist_km=None, row_idx=None, feedback=None):
        if lat < -90 or lat > 90:
            if feedback and row_idx is not None:
                feedback.reportError(f"Linha {row_idx}: latitude fora do intervalo [-90, 90]: {lat}")
            raise ValueError("Latitude inválida")
        if lon < -180 or lon > 180:
            if feedback and row_idx is not None:
                feedback.reportError(f"Linha {row_idx}: longitude fora do intervalo [-180, 180]: {lon}")
            raise ValueError("Longitude inválida")
        if dist_km is not None and dist_km < 0:
            if feedback and row_idx is not None:
                feedback.reportError(f"Linha {row_idx}: distância negativa (km): {dist_km}")
            raise ValueError("Distância inválida")
        if azi is not None:
            azi_norm = (azi % 360 + 360) % 360
            return azi_norm
        return None

    def createInstance(self):
        return LinhasGeoIMEAlgorithm()

    def name(self):
        return 'geodesic_lines_advanced'

    def displayName(self):
        return self.tr('Linhas Geodésicas (Múltiplos Métodos)')

    def initAlgorithm(self, config=None):
        # 1. Selecionar tipo de problema
        self.addParameter(QgsProcessingParameterEnum(
            'PROBLEM_TYPE',
            self.tr('Tipo de cálculo'),
            options=[self.tr('Inverso: lat1,lon1,lat2,lon2'),
                     self.tr('Direto: lat1,lon1,azi1,dist')],
            defaultValue=0))

        # 2. Selecionar método geodésico
        self.addParameter(QgsProcessingParameterEnum(
            'METHOD',
            self.tr('Método Geodésico'),
            options=[self.tr('Karney/WGS84'),
                     self.tr('Vincenty/WGS84'),
                     self.tr('Bessel')],
            defaultValue=0))

        # 3. Arquivo CSV (compatível com ambos os formatos)
        self.addParameter(QgsProcessingParameterFile(
            'INPUT_CSV',
            self.tr('Arquivo CSV'),
            extension='csv'))

        # 4. Saída
        self.addParameter(QgsProcessingParameterFeatureSink(
            'OUTPUT',
            self.tr('Linhas geodésicas')))

    def processAlgorithm(self, parameters, context, feedback):
        problem_type = self.parameterAsEnum(parameters, 'PROBLEM_TYPE', context)
        method = self.parameterAsEnum(parameters, 'METHOD', context)
        csv_path = self.parameterAsFile(parameters, 'INPUT_CSV', context)

        fields = QgsFields()
        sink, dest_id = self.parameterAsSink(
            parameters, 'OUTPUT', context,
            fields, QgsWkbTypes.LineString,
            QgsCoordinateReferenceSystem('EPSG:4326'))

        if method == 0:
            geod = Geodesic.WGS84
            with open(csv_path, 'r') as f:
                reader = csv.DictReader(f)
                for row_idx, row in enumerate(reader, start=2):
                    points = []
                    if problem_type == 0:
                        try:
                            lat1 = self._read_float(row, ['lat1', 'lat inicial'], row_idx, feedback)
                            lon1 = self._read_float(row, ['lon1', 'long inicial'], row_idx, feedback)
                            lat2 = self._read_float(row, ['lat2', 'lat final'], row_idx, feedback)
                            lon2 = self._read_float(row, ['lon2', 'long final'], row_idx, feedback)
                            self._check_ranges(lat1, lon1, row_idx=row_idx, feedback=feedback)
                            self._check_ranges(lat2, lon2, row_idx=row_idx, feedback=feedback)
                            inv = geod.Inverse(lat1, lon1, lat2, lon2)
                            line = geod.Line(lat1, lon1, inv['azi1'])
                            points.append(QgsPointXY(lon1, lat1))
                            total_dist = inv['s12']
                            steps = max(10, int(total_dist / 1000))
                            for i in range(1, steps + 1):
                                dist = (i / steps) * total_dist
                                pos = line.Position(dist)
                                points.append(QgsPointXY(pos['lon2'], pos['lat2']))
                        except (KeyError, ValueError) as e:
                            feedback.reportError(f"Erro no problema inverso (linha {row_idx}): {str(e)}")
                            continue
                    else:
                        try:
                            lat1 = self._read_float(row, ['lat1', 'lat inicial'], row_idx, feedback)
                            lon1 = self._read_float(row, ['lon1', 'long inicial'], row_idx, feedback)
                            azi1 = self._read_float(row, ['azi1', 'azimute'], row_idx, feedback)
                            dist_km = self._read_float(row, ['dist', 'distancia (km)'], row_idx, feedback)
                            self._check_ranges(lat1, lon1, row_idx=row_idx, feedback=feedback)
                            azi1 = self._check_ranges(lat1, lon1, azi=azi1, row_idx=row_idx, feedback=feedback) or azi1
                            self._check_ranges(lat1, lon1, dist_km=dist_km, row_idx=row_idx, feedback=feedback)
                            points.append(QgsPointXY(lon1, lat1))
                            line = geod.Line(lat1, lon1, azi1)
                            total_dist = dist_km * 1000.0
                            steps = max(10, int(total_dist / 1000))
                            for i in range(1, steps + 1):
                                dist = (i / steps) * total_dist
                                pos = line.Position(dist)
                                points.append(QgsPointXY(pos['lon2'], pos['lat2']))
                        except (KeyError, ValueError) as e:
                            feedback.reportError(f"Erro no problema direto (linha {row_idx}): {str(e)}")
                            continue
                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromPolylineXY(points))
                    sink.addFeature(feat)
        elif method == 1:
            features = self.calcular_com_vincenty(csv_path,
                                                  'Inverso' if problem_type == 0 else 'Direto',
                                                  feedback)
            for feat in features:
                sink.addFeature(feat)
        else:
            features = self.calcular_com_bessel(csv_path,
                                                'Inverso' if problem_type == 0 else 'Direto',
                                                feedback)
            for feat in features:
                sink.addFeature(feat)

        return {'OUTPUT': dest_id}

    def calcular_com_vincenty(self, caminho_arquivo, metodo, feedback):
        df = pd.read_csv(caminho_arquivo)
        geod = Geodesic.WGS84
        features = []

        def pontos_antipodais(lat1, lon1, lat2, lon2, tol=1e-5):
            cond_lat = abs(lat1 + lat2) < tol
            dlon = abs((lon1 - lon2 + 180) % 360 - 180)
            cond_lon = abs(dlon - 180) < tol
            return cond_lat and cond_lon

        if metodo == 'Inverso':
            for i, row in df.iterrows():
                row_idx = int(i) + 2
                try:
                    lat1 = self._read_float(row, ['lat1', 'lat inicial'], row_idx, feedback)
                    lon1 = self._read_float(row, ['lon1', 'long inicial'], row_idx, feedback)
                    lat2 = self._read_float(row, ['lat2', 'lat final'], row_idx, feedback)
                    lon2 = self._read_float(row, ['lon2', 'long final'], row_idx, feedback)
                    self._check_ranges(lat1, lon1, row_idx=row_idx, feedback=feedback)
                    self._check_ranges(lat2, lon2, row_idx=row_idx, feedback=feedback)
                    if pontos_antipodais(lat1, lon1, lat2, lon2):
                        feedback.reportError(f"Linha {row_idx}: pontos antípodas para Vincenty; use Karney.")
                        continue
                    inv = geod.Inverse(lat1, lon1, lat2, lon2)
                    line = geod.Line(lat1, lon1, inv['azi1'])
                    total_dist = inv['s12']
                    steps = max(10, int(total_dist / 1000))
                    points = [QgsPointXY(lon1, lat1)]
                    for i in range(1, steps + 1):
                        dist = (i / steps) * total_dist
                        pos = line.Position(dist)
                        points.append(QgsPointXY(pos['lon2'], pos['lat2']))
                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromPolylineXY(points))
                    features.append(feat)
                except Exception as e:
                    feedback.reportError(f"Erro Vincenty Inverso (linha {row_idx}): {str(e)}")
                    continue

        elif metodo == 'Direto':
            for i, row in df.iterrows():
                row_idx = int(i) + 2
                try:
                    lat1 = self._read_float(row, ['lat1', 'lat inicial'], row_idx, feedback)
                    lon1 = self._read_float(row, ['lon1', 'long inicial'], row_idx, feedback)
                    azi1 = self._read_float(row, ['azi1', 'azimute'], row_idx, feedback)
                    dist = self._read_float(row, ['dist', 'distancia (km)'], row_idx, feedback)
                    self._check_ranges(lat1, lon1, row_idx=row_idx, feedback=feedback)
                    azi1 = self._check_ranges(lat1, lon1, azi=azi1, row_idx=row_idx, feedback=feedback) or azi1
                    self._check_ranges(lat1, lon1, dist_km=dist, row_idx=row_idx, feedback=feedback)
                    line = geod.Line(lat1, lon1, azi1)
                    total_dist = dist * 1000.0
                    steps = max(10, int(total_dist / 1000))
                    points = [QgsPointXY(lon1, lat1)]
                    for i in range(1, steps + 1):
                        dist_step = (i / steps) * total_dist
                        pos = line.Position(dist_step)
                        points.append(QgsPointXY(pos['lon2'], pos['lat2']))
                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromPolylineXY(points))
                    features.append(feat)
                except Exception as e:
                    feedback.reportError(f"Erro Vincenty Direto (linha {row_idx}): {str(e)}")
                    continue

        return features

    def calcular_com_bessel(self, caminho_arquivo, metodo, feedback):
        df = pd.read_csv(caminho_arquivo)
        geod = Geodesic(6377397.155, 1/299.1528128)
        features = []

        def has_value(row, key):
            return key in row and str(row[key]).strip() != ''

        for i, row in df.iterrows():
            row_idx = int(i) + 2
            try:
                direto = (
                    (has_value(row, 'dist') or has_value(row, 'distancia (km)')) and
                    (has_value(row, 'azi1') or has_value(row, 'azimute'))
                )

                if direto:
                    lat1 = self._read_float(row, ['lat1', 'lat inicial'], row_idx, feedback)
                    lon1 = self._read_float(row, ['lon1', 'long inicial'], row_idx, feedback)
                    azimute = self._read_float(row, ['azi1', 'azimute'], row_idx, feedback)
                    dist_km = self._read_float(row, ['dist', 'distancia (km)'], row_idx, feedback)
                    self._check_ranges(lat1, lon1, row_idx=row_idx, feedback=feedback)
                    azimute = self._check_ranges(lat1, lon1, azi=azimute, row_idx=row_idx, feedback=feedback) or azimute
                    self._check_ranges(lat1, lon1, dist_km=dist_km, row_idx=row_idx, feedback=feedback)
                    line = geod.Line(lat1, lon1, azimute)
                    total_dist = float(dist_km) * 1000.0
                    steps = max(10, int(total_dist / 1000))
                    points = [QgsPointXY(lon1, lat1)]
                    for j in range(1, steps + 1):
                        dist_step = (j / steps) * total_dist
                        pos = line.Position(dist_step)
                        points.append(QgsPointXY(pos['lon2'], pos['lat2']))
                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromPolylineXY(points))
                    features.append(feat)
                else:
                    lat1 = self._read_float(row, ['lat1', 'lat inicial'], row_idx, feedback)
                    lon1 = self._read_float(row, ['lon1', 'long inicial'], row_idx, feedback)
                    lat2 = self._read_float(row, ['lat2', 'lat final'], row_idx, feedback)
                    lon2 = self._read_float(row, ['lon2', 'long final'], row_idx, feedback)
                    self._check_ranges(lat1, lon1, row_idx=row_idx, feedback=feedback)
                    self._check_ranges(lat2, lon2, row_idx=row_idx, feedback=feedback)
                    inv = geod.Inverse(lat1, lon1, lat2, lon2)
                    line = geod.Line(lat1, lon1, inv['azi1'])
                    total_dist = inv['s12']
                    steps = max(10, int(total_dist / 1000))
                    points = [QgsPointXY(lon1, lat1)]
                    for j in range(1, steps + 1):
                        dist_step = (j / steps) * total_dist
                        pos = line.Position(dist_step)
                        points.append(QgsPointXY(pos['lon2'], pos['lat2']))
                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromPolylineXY(points))
                    features.append(feat)

            except Exception as e:
                feedback.reportError(f"Erro Bessel (linha {row_idx}): {str(e)}")
                continue

        return features
